{
  "questions": [
    {
      "title": "Which of the following is an option for the useFetch composable?",
      "options": [
        { "id": "1", "text": "translate" },
        { "id": "2", "text": "none of these" },
        { "id": "3", "text": "event" }
      ],
      "correctId": "2",
      "explanation": "useFetch supports options like key, method, query, headers, etc. but not 'translate' or 'event'."
    },
    {
      "title": "Server middleware handlers will run on every request before any other server route to:",
      "options": [
        { "id": "1", "text": "Extend the event's request object" },
        { "id": "2", "text": "All of these" },
        { "id": "3", "text": "Log requests" },
        { "id": "4", "text": "Add or check headers" }
      ],
      "correctId": "2",
      "explanation": "Server middleware can extend requests, log them, and add or check headers â€” all of these."
    },
    {
      "title": "What is the advantage of useSeoMeta over useHead?",
      "options": [
        {
          "id": "1",
          "text": "It can handle reactive values, while useHead cannot"
        },
        { "id": "2", "text": "There is no advantage" },
        {
          "id": "3",
          "text": "It's slightly more performant since it relies on no external dependencies"
        },
        { "id": "4", "text": "It helps you avoid typos and common mistakes" }
      ],
      "correctId": "4",
      "explanation": "useSeoMeta adds helpers for common SEO fields and prevents mistakes when defining meta tags."
    },
    {
      "title": "The createError function can accept an object that includes (but is not limited to) which properties?",
      "options": [
        { "id": "1", "text": "msg, statusMsg, status" },
        { "id": "2", "text": "status, fatal, message" },
        { "id": "3", "text": "statusCode, fatal, message" },
        { "id": "4", "text": "name, statusCode, msg" }
      ],
      "correctId": "3",
      "explanation": "createError accepts objects with properties such as statusCode, fatal, and message."
    },
    {
      "title": "Route middleware runs on...",
      "options": [
        { "id": "1", "text": "The server" },
        { "id": "2", "text": "Both of these" },
        { "id": "3", "text": "The client" }
      ],
      "correctId": "2",
      "explanation": "Route middleware can run on both client and server depending on navigation and rendering context."
    },
    {
      "title": "Assets served from the assets directory exist at a static, predictable URL that never changes unless the filename changes.",
      "options": [
        { "id": "1", "text": "false" },
        { "id": "2", "text": "true" }
      ],
      "correctId": "1",
      "explanation": "Assets are processed and bundled by Vite, unlike files in /public which are static at predictable URLs."
    },
    {
      "title": "Given the following code, will the page title reactively update when the title property on the post reactive ref updates?",
      "options": [
        { "id": "1", "text": "Yes" },
        { "id": "2", "text": "No" }
      ],
      "correctId": "2",
      "explanation": "Passing post.value.title makes it static. To make it reactive, use a function: title: () => post.value.title."
    },
    {
      "title": "What command is used for bootstrapping a new Nuxt project?",
      "options": [
        { "id": "1", "text": "npx nuxt init" },
        { "id": "2", "text": "npx nuxi@latest init" },
        { "id": "3", "text": "None of these" },
        { "id": "4", "text": "npm create nuxt-project" }
      ],
      "correctId": "2",
      "explanation": "The official command is npx nuxi@latest init <project-name>."
    },
    {
      "title": "Which of the following is NOT true about file-based routing?",
      "options": [
        {
          "id": "1",
          "text": "You must enable it in nuxt.config.ts like this fileBasedRouting: true"
        },
        {
          "id": "2",
          "text": "You can create a catch all route by creating the file: pages/[...slug].vue"
        },
        {
          "id": "3",
          "text": "Files under the pages directory are automatically turned into routes"
        },
        { "id": "4", "text": "It supports creating routes with dynamic params" }
      ],
      "correctId": "1",
      "explanation": "File-based routing is enabled by default and does not require configuration in nuxt.config.ts."
    },
    {
      "title": "What is Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "A CSS framework"
        },
        {
          "id": "2",
          "text": "A Vue.js framework"
        },
        {
          "id": "3",
          "text": "A React framework"
        },
        {
          "id": "4",
          "text": "A database"
        },
        {
          "id": "5",
          "text": "A testing library"
        }
      ],
      "correctId": "2",
      "explanation": "Nuxt 3 is a modern framework built on top of Vue 3, designed for building performant web applications with features like SSR, SSG, and SPA modes."
    },
    {
      "title": "Which rendering mode is NOT supported by Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Server-Side Rendering (SSR)"
        },
        {
          "id": "2",
          "text": "Static Site Generation (SSG)"
        },
        {
          "id": "3",
          "text": "Single Page Application (SPA)"
        },
        {
          "id": "4",
          "text": "Client-Side Rendering (CSR)"
        },
        {
          "id": "5",
          "text": "Dynamic Site Generation (DSG)"
        }
      ],
      "correctId": "5",
      "explanation": "Nuxt 3 supports SSR, SSG, SPA, and CSR modes, but Dynamic Site Generation (DSG) is a Gatsby-specific feature not available in Nuxt."
    },
    {
      "title": "What is the correct way to define a page in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file in the /src/pages/ directory"
        },
        {
          "id": "2",
          "text": "Create a file in the /pages/ directory"
        },
        {
          "id": "3",
          "text": "Create a file in the /components/ directory"
        },
        {
          "id": "4",
          "text": "Create a file in the /views/ directory"
        },
        {
          "id": "5",
          "text": "Register it in nuxt.config.ts"
        }
      ],
      "correctId": "2",
      "explanation": "In Nuxt 3, pages are automatically created by placing Vue files in the /pages/ directory, leveraging file-based routing."
    },
    {
      "title": "Which script setup syntax is correct for Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "<script setup lang=\"ts\">"
        },
        {
          "id": "2",
          "text": "<script setup=\"true\">"
        },
        {
          "id": "3",
          "text": "<script type=\"setup\">"
        },
        {
          "id": "4",
          "text": "<script mode=\"setup\">"
        },
        {
          "id": "5",
          "text": "<script composition>"
        }
      ],
      "correctId": "1",
      "explanation": "The correct syntax is <script setup lang=\"ts\"> for TypeScript or <script setup> for JavaScript, which enables the Composition API setup syntax."
    },
    {
      "title": "What is the purpose of the useState composable in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To handle HTTP requests"
        },
        {
          "id": "2",
          "text": "To manage shared reactive state"
        },
        {
          "id": "3",
          "text": "To define component props"
        },
        {
          "id": "4",
          "text": "To configure routing"
        },
        {
          "id": "5",
          "text": "To handle form validation"
        }
      ],
      "correctId": "2",
      "explanation": "useState is a server-safe reactive state management composable that creates shared state across components and ensures hydration consistency."
    },
    {
      "title": "How do you fetch data in Nuxt 3 using the $fetch utility?",
      "options": [
        {
          "id": "1",
          "text": "const data = $fetch('/api/users')"
        },
        {
          "id": "2",
          "text": "const data = await $fetch('/api/users')"
        },
        {
          "id": "3",
          "text": "const data = $fetch.get('/api/users')"
        },
        {
          "id": "4",
          "text": "const data = fetch('/api/users')"
        },
        {
          "id": "5",
          "text": "const data = useFetch('/api/users')"
        }
      ],
      "correctId": "2",
      "explanation": "$fetch is a promise-based utility that requires await when used for data fetching, providing automatic request/response parsing."
    },
    {
      "title": "Which directory is used for Nuxt 3 layouts?",
      "options": [
        {
          "id": "1",
          "text": "/templates/"
        },
        {
          "id": "2",
          "text": "/layouts/"
        },
        {
          "id": "3",
          "text": "/views/"
        },
        {
          "id": "4",
          "text": "/pages/"
        },
        {
          "id": "5",
          "text": "/components/"
        }
      ],
      "correctId": "2",
      "explanation": "Layouts in Nuxt 3 are placed in the /layouts/ directory and provide a template structure that wraps around pages."
    },
    {
      "title": "What is the correct way to define a dynamic route in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file named [id].vue"
        },
        {
          "id": "2",
          "text": "Create a file named :id.vue"
        },
        {
          "id": "3",
          "text": "Create a file named {id}.vue"
        },
        {
          "id": "4",
          "text": "Create a file named $id.vue"
        },
        {
          "id": "5",
          "text": "Create a file named id.vue"
        }
      ],
      "correctId": "1",
      "explanation": "Dynamic routes in Nuxt 3 are created using square brackets, like [id].vue, which creates a route parameter accessible via useRoute()."
    },
    {
      "title": "Nuxt 3 is built on top of which Vue version?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "1",
      "explanation": "Nuxt 3 is built on top of Vue 3, taking advantage of its Composition API, better performance, and modern features."
    },
    {
      "title": "What is the purpose of the public/ directory in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Store Vue components"
        },
        {
          "id": "2",
          "text": "Store static assets served at root"
        },
        {
          "id": "3",
          "text": "Store page files"
        },
        {
          "id": "4",
          "text": "Store configuration files"
        },
        {
          "id": "5",
          "text": "Store server API routes"
        }
      ],
      "correctId": "2",
      "explanation": "The public/ directory contains static assets that are served directly at the root URL without processing, like images, fonts, and favicon."
    },
    {
      "title": "Which composable should you use for reactive data that needs to persist across navigation?",
      "options": [
        {
          "id": "1",
          "text": "ref()"
        },
        {
          "id": "2",
          "text": "reactive()"
        },
        {
          "id": "3",
          "text": "useState()"
        },
        {
          "id": "4",
          "text": "computed()"
        },
        {
          "id": "5",
          "text": "watch()"
        }
      ],
      "correctId": "3",
      "explanation": "useState() is specifically designed for shared state that persists across page navigation and ensures server-client hydration consistency."
    },
    {
      "title": "What is the correct syntax to access route parameters in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const route = useRoute(); route.params.id"
        },
        {
          "id": "2",
          "text": "const router = useRouter(); router.params.id"
        },
        {
          "id": "3",
          "text": "const params = useParams(); params.id"
        },
        {
          "id": "4",
          "text": "this.$route.params.id"
        },
        {
          "id": "5",
          "text": "const id = useParam('id')"
        }
      ],
      "correctId": "1",
      "explanation": "In Nuxt 3, you use useRoute() composable to access the current route object and its parameters via route.params."
    },
    {
      "title": "How do you define a server API route in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file in /api/ directory"
        },
        {
          "id": "2",
          "text": "Create a file in /server/api/ directory"
        },
        {
          "id": "3",
          "text": "Create a file in /pages/api/ directory"
        },
        {
          "id": "4",
          "text": "Create a file in /routes/ directory"
        },
        {
          "id": "5",
          "text": "Define it in nuxt.config.ts"
        }
      ],
      "correctId": "2",
      "explanation": "Server API routes in Nuxt 3 are created by placing files in the /server/api/ directory, automatically creating endpoints."
    },
    {
      "title": "What is the difference between assets/ and public/ directories?",
      "options": [
        {
          "id": "1",
          "text": "assets/ for images, public/ for fonts"
        },
        {
          "id": "2",
          "text": "assets/ are processed by build tools, public/ are served directly"
        },
        {
          "id": "3",
          "text": "assets/ for development, public/ for production"
        },
        {
          "id": "4",
          "text": "No difference, both work the same"
        },
        {
          "id": "5",
          "text": "assets/ for CSS, public/ for JavaScript"
        }
      ],
      "correctId": "2",
      "explanation": "Files in assets/ are processed by build tools (Vite) and can be optimized, while public/ files are served directly without processing."
    },
    {
      "title": "Which command creates a new Nuxt 3 project?",
      "options": [
        {
          "id": "1",
          "text": "npx create-nuxt-app"
        },
        {
          "id": "2",
          "text": "npx nuxi@latest init"
        },
        {
          "id": "3",
          "text": "npm create nuxt"
        },
        {
          "id": "4",
          "text": "vue create nuxt-app"
        },
        {
          "id": "5",
          "text": "nuxt create"
        }
      ],
      "correctId": "2",
      "explanation": "The correct command to create a new Nuxt 3 project is 'npx nuxi@latest init project-name' using the Nuxi CLI."
    },
    {
      "title": "What is the purpose of the <NuxtPage> component?",
      "options": [
        {
          "id": "1",
          "text": "To display the current page component"
        },
        {
          "id": "2",
          "text": "To handle navigation"
        },
        {
          "id": "3",
          "text": "To load external scripts"
        },
        {
          "id": "4",
          "text": "To manage SEO meta tags"
        },
        {
          "id": "5",
          "text": "To handle error pages"
        }
      ],
      "correctId": "1",
      "explanation": "<NuxtPage> is used in layouts to display the current page component, acting as a placeholder for routed content."
    },
    {
      "title": "How do you navigate programmatically in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const router = useRouter(); router.push('/path')"
        },
        {
          "id": "2",
          "text": "const navigate = useNavigate(); navigate('/path')"
        },
        {
          "id": "3",
          "text": "navigateTo('/path')"
        },
        {
          "id": "4",
          "text": "this.$router.push('/path')"
        },
        {
          "id": "5",
          "text": "All options are correct"
        }
      ],
      "correctId": "5",
      "explanation": "Both useRouter().push() and navigateTo() are valid approaches for programmatic navigation in Nuxt 3, with navigateTo() being the Nuxt-specific helper."
    },
    {
      "title": "What is the purpose of useFetch in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To fetch data only on the client side"
        },
        {
          "id": "2",
          "text": "To fetch data with SSR support and caching"
        },
        {
          "id": "3",
          "text": "To handle form submissions"
        },
        {
          "id": "4",
          "text": "To manage component state"
        },
        {
          "id": "5",
          "text": "To configure HTTP headers"
        }
      ],
      "correctId": "2",
      "explanation": "useFetch provides universal data fetching with automatic SSR support, caching, and hydration handling between server and client."
    },
    {
      "title": "Which file is used for global Nuxt 3 configuration?",
      "options": [
        {
          "id": "1",
          "text": "nuxt.config.js"
        },
        {
          "id": "2",
          "text": "nuxt.config.ts"
        },
        {
          "id": "3",
          "text": "app.config.ts"
        },
        {
          "id": "4",
          "text": "Both nuxt.config.ts and app.config.ts"
        },
        {
          "id": "5",
          "text": "config.nuxt.ts"
        }
      ],
      "correctId": "4",
      "explanation": "Both nuxt.config.ts (build-time configuration) and app.config.ts (runtime configuration) are used for different types of Nuxt 3 configuration."
    },
    {
      "title": "What is the correct way to define a catch-all route in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file named [...slug].vue"
        },
        {
          "id": "2",
          "text": "Create a file named [*].vue"
        },
        {
          "id": "3",
          "text": "Create a file named [all].vue"
        },
        {
          "id": "4",
          "text": "Create a file named [...].vue"
        },
        {
          "id": "5",
          "text": "Create a file named [slug].vue"
        }
      ],
      "correctId": "1",
      "explanation": "Catch-all routes in Nuxt 3 are created using the [...slug].vue syntax, where 'slug' can be any parameter name."
    },
    {
      "title": "How do you add custom CSS in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Place CSS files in /assets/css/ and configure in nuxt.config.ts"
        },
        {
          "id": "2",
          "text": "Import CSS in main.js"
        },
        {
          "id": "3",
          "text": "Add CSS to /public/styles/"
        },
        {
          "id": "4",
          "text": "Use only <style> tags in components"
        },
        {
          "id": "5",
          "text": "CSS is not supported in Nuxt 3"
        }
      ],
      "correctId": "1",
      "explanation": "Custom CSS can be added by placing files in /assets/css/ and configuring them in the css array of nuxt.config.ts."
    },
    {
      "title": "What is the purpose of middleware in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To handle database connections"
        },
        {
          "id": "2",
          "text": "To run code before navigation to routes"
        },
        {
          "id": "3",
          "text": "To manage component lifecycle"
        },
        {
          "id": "4",
          "text": "To handle HTTP requests"
        },
        {
          "id": "5",
          "text": "To configure build process"
        }
      ],
      "correctId": "2",
      "explanation": "Middleware in Nuxt 3 allows you to run custom code before navigation to specific routes, useful for authentication, validation, or redirects."
    },
    {
      "title": "Which composable is used to manage document head in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "useMeta()"
        },
        {
          "id": "2",
          "text": "useHead()"
        },
        {
          "id": "3",
          "text": "useSEO()"
        },
        {
          "id": "4",
          "text": "useTitle()"
        },
        {
          "id": "5",
          "text": "useDocument()"
        }
      ],
      "correctId": "2",
      "explanation": "useHead() is the composable used to manage document head elements like title, meta tags, and scripts in Nuxt 3."
    },
    {
      "title": "What is the correct syntax for a named layout in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "definePageMeta({ layout: 'custom' })"
        },
        {
          "id": "2",
          "text": "setLayout('custom')"
        },
        {
          "id": "3",
          "text": "useLayout('custom')"
        },
        {
          "id": "4",
          "text": "layout: 'custom' in <script>"
        },
        {
          "id": "5",
          "text": "<template layout=\"custom\">"
        }
      ],
      "correctId": "1",
      "explanation": "Named layouts are specified using definePageMeta({ layout: 'layoutName' }) at the top level of a page component."
    },
    {
      "title": "How do you handle errors globally in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create an error.vue file in the root"
        },
        {
          "id": "2",
          "text": "Use try-catch in every component"
        },
        {
          "id": "3",
          "text": "Configure error handling in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Use the useError composable"
        },
        {
          "id": "5",
          "text": "Create an error page in /pages/"
        }
      ],
      "correctId": "1",
      "explanation": "Global error handling in Nuxt 3 is implemented by creating an error.vue file in the project root, which will be used for all unhandled errors."
    },
    {
      "title": "What is the purpose of plugins in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To extend Vue functionality before app creation"
        },
        {
          "id": "2",
          "text": "To handle routing"
        },
        {
          "id": "3",
          "text": "To manage state"
        },
        {
          "id": "4",
          "text": "To configure build tools"
        },
        {
          "id": "5",
          "text": "To handle API requests"
        }
      ],
      "correctId": "1",
      "explanation": "Plugins in Nuxt 3 allow you to extend Vue functionality, register global components, add composables, or run code before the app is created."
    },
    {
      "title": "Which directory contains Nuxt 3 plugins?",
      "options": [
        {
          "id": "1",
          "text": "/src/plugins/"
        },
        {
          "id": "2",
          "text": "/plugins/"
        },
        {
          "id": "3",
          "text": "/modules/"
        },
        {
          "id": "4",
          "text": "/extensions/"
        },
        {
          "id": "5",
          "text": "/addons/"
        }
      ],
      "correctId": "2",
      "explanation": "Plugins in Nuxt 3 are placed in the /plugins/ directory and are automatically registered when the application starts."
    },
    {
      "title": "What does the useLazyFetch composable do?",
      "options": [
        {
          "id": "1",
          "text": "Fetches data only on user interaction"
        },
        {
          "id": "2",
          "text": "Fetches data asynchronously without blocking navigation"
        },
        {
          "id": "3",
          "text": "Fetches data with a delay"
        },
        {
          "id": "4",
          "text": "Fetches data only once"
        },
        {
          "id": "5",
          "text": "Fetches data in the background"
        }
      ],
      "correctId": "2",
      "explanation": "useLazyFetch fetches data asynchronously without blocking client-side navigation, improving perceived performance by not waiting for data resolution."
    },
    {
      "title": "Is Nuxt 3 fully compatible with Vue 2 components?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "2",
      "explanation": "Nuxt 3 is built on Vue 3 and is not fully compatible with Vue 2 components due to breaking changes in Vue 3's API and architecture."
    },
    {
      "title": "What is the correct way to define metadata for a page?",
      "options": [
        {
          "id": "1",
          "text": "definePageMeta({})"
        },
        {
          "id": "2",
          "text": "useMeta({})"
        },
        {
          "id": "3",
          "text": "setPageMeta({})"
        },
        {
          "id": "4",
          "text": "pageMetadata: {}"
        },
        {
          "id": "5",
          "text": "export const meta = {}"
        }
      ],
      "correctId": "1",
      "explanation": "definePageMeta() is used to define page-specific metadata like layout, middleware, and other route-level configuration in Nuxt 3."
    },
    {
      "title": "How do you create a custom 404 page in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a 404.vue file in /pages/"
        },
        {
          "id": "2",
          "text": "Create a [...slug].vue file in /pages/"
        },
        {
          "id": "3",
          "text": "Create a not-found.vue file in /pages/"
        },
        {
          "id": "4",
          "text": "Configure it in nuxt.config.ts"
        },
        {
          "id": "5",
          "text": "Create an error.vue file in root"
        }
      ],
      "correctId": "2",
      "explanation": "A custom 404 page is created using a catch-all route [...slug].vue in the /pages/ directory, which handles all unmatched routes."
    },
    {
      "title": "What is the purpose of the <NuxtLink> component?",
      "options": [
        {
          "id": "1",
          "text": "To create external links"
        },
        {
          "id": "2",
          "text": "To provide client-side navigation"
        },
        {
          "id": "3",
          "text": "To handle form submissions"
        },
        {
          "id": "4",
          "text": "To load components dynamically"
        },
        {
          "id": "5",
          "text": "To manage route parameters"
        }
      ],
      "correctId": "2",
      "explanation": "<NuxtLink> provides optimized client-side navigation between pages with features like prefetching and intelligent loading strategies."
    },
    {
      "title": "Which is the correct syntax for reactive state in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const count = reactive(0)"
        },
        {
          "id": "2",
          "text": "const count = ref(0)"
        },
        {
          "id": "3",
          "text": "const count = useState('count', () => 0)"
        },
        {
          "id": "4",
          "text": "All options are correct"
        },
        {
          "id": "5",
          "text": "No option is correct"
        }
      ],
      "correctId": "4",
      "explanation": "All three options are valid ways to create reactive state in Nuxt 3, each serving different purposes: reactive() for objects, ref() for primitives, and useState() for shared state."
    },
    {
      "title": "What is the difference between server and client rendering in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Server rendering happens on server, client rendering in browser"
        },
        {
          "id": "2",
          "text": "Server rendering is faster"
        },
        {
          "id": "3",
          "text": "Client rendering is more secure"
        },
        {
          "id": "4",
          "text": "No difference in Nuxt 3"
        },
        {
          "id": "5",
          "text": "Server rendering only works in production"
        }
      ],
      "correctId": "1",
      "explanation": "Server rendering generates HTML on the server before sending to the browser, while client rendering generates HTML in the browser using JavaScript."
    },
    {
      "title": "How do you access environment variables in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "process.env.VARIABLE_NAME"
        },
        {
          "id": "2",
          "text": "useRuntimeConfig().VARIABLE_NAME"
        },
        {
          "id": "3",
          "text": "$config.VARIABLE_NAME"
        },
        {
          "id": "4",
          "text": "import.meta.env.VARIABLE_NAME"
        },
        {
          "id": "5",
          "text": "All options are correct"
        }
      ],
      "correctId": "2",
      "explanation": "useRuntimeConfig() is the recommended way to access environment variables in Nuxt 3, providing reactive access to runtime configuration."
    },
    {
      "title": "What is the purpose of the <ClientOnly> component?",
      "options": [
        {
          "id": "1",
          "text": "To render components only on the client side"
        },
        {
          "id": "2",
          "text": "To optimize server performance"
        },
        {
          "id": "3",
          "text": "To handle authentication"
        },
        {
          "id": "4",
          "text": "To manage routing"
        },
        {
          "id": "5",
          "text": "To load external scripts"
        }
      ],
      "correctId": "1",
      "explanation": "<ClientOnly> wraps components that should only be rendered on the client side, useful for components that depend on browser APIs or cause hydration issues."
    },
    {
      "title": "How do you configure TypeScript in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Install @nuxt/typescript-build"
        },
        {
          "id": "2",
          "text": "TypeScript support is built-in"
        },
        {
          "id": "3",
          "text": "Configure webpack for TypeScript"
        },
        {
          "id": "4",
          "text": "Add typescript: true to nuxt.config.ts"
        },
        {
          "id": "5",
          "text": "Install vue-tsc separately"
        }
      ],
      "correctId": "2",
      "explanation": "Nuxt 3 has built-in TypeScript support out of the box, requiring no additional configuration for basic TypeScript usage."
    },
    {
      "title": "What is the correct way to handle loading states with useFetch?",
      "options": [
        {
          "id": "1",
          "text": "const { data, pending } = await useFetch('/api/data')"
        },
        {
          "id": "2",
          "text": "const { data, loading } = useFetch('/api/data')"
        },
        {
          "id": "3",
          "text": "const { data, pending } = useFetch('/api/data')"
        },
        {
          "id": "4",
          "text": "const { data, isLoading } = useFetch('/api/data')"
        },
        {
          "id": "5",
          "text": "const { data, status } = useFetch('/api/data')"
        }
      ],
      "correctId": "3",
      "explanation": "useFetch returns a 'pending' reactive property that indicates whether the request is still in progress, useful for showing loading states."
    },
    {
      "title": "Which CSS framework is officially supported by Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Tailwind CSS"
        },
        {
          "id": "2",
          "text": "Bootstrap"
        },
        {
          "id": "3",
          "text": "Bulma"
        },
        {
          "id": "4",
          "text": "All of the above"
        },
        {
          "id": "5",
          "text": "None specifically, but all can be integrated"
        }
      ],
      "correctId": "5",
      "explanation": "Nuxt 3 doesn't officially endorse a specific CSS framework but provides easy integration methods for popular frameworks like Tailwind, Bootstrap, and others."
    },
    {
      "title": "How do you define a server API route that accepts POST requests?",
      "options": [
        {
          "id": "1",
          "text": "export default defineEventHandler(async (event) => { if (event.node.req.method !== 'POST') return; })"
        },
        {
          "id": "2",
          "text": "export default defineEventHandler.post(async (event) => {})"
        },
        {
          "id": "3",
          "text": "export const post = defineEventHandler(async (event) => {})"
        },
        {
          "id": "4",
          "text": "Name the file users.post.ts"
        },
        {
          "id": "5",
          "text": "Both option 1 and 4 are correct"
        }
      ],
      "correctId": "5",
      "explanation": "POST requests can be handled by checking the method inside defineEventHandler or by using the HTTP method naming convention like users.post.ts."
    },
    {
      "title": "What is the purpose of the refreshCookie() function?",
      "options": [
        {
          "id": "1",
          "text": "To update cookie expiration time"
        },
        {
          "id": "2",
          "text": "To refresh cookie values from server"
        },
        {
          "id": "3",
          "text": "To clear all cookies"
        },
        {
          "id": "4",
          "text": "To encrypt cookie data"
        },
        {
          "id": "5",
          "text": "This function doesn't exist in Nuxt 3"
        }
      ],
      "correctId": "2",
      "explanation": "refreshCookie() is used to refresh cookie values from the server, ensuring the client has the latest cookie data."
    },
    {
      "title": "Does Nuxt 3 support automatic code splitting?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "1",
      "explanation": "Nuxt 3 automatically implements code splitting, creating separate chunks for different routes and components to optimize loading performance."
    },
    {
      "title": "What is the correct way to add global styles in nuxt.config.ts?",
      "options": [
        {
          "id": "1",
          "text": "export default defineNuxtConfig({ css: ['~/assets/css/main.css'] })"
        },
        {
          "id": "2",
          "text": "export default defineNuxtConfig({ styles: ['~/assets/css/main.css'] })"
        },
        {
          "id": "3",
          "text": "export default defineNuxtConfig({ globalCSS: ['~/assets/css/main.css'] })"
        },
        {
          "id": "4",
          "text": "export default defineNuxtConfig({ imports: ['~/assets/css/main.css'] })"
        },
        {
          "id": "5",
          "text": "export default defineNuxtConfig({ head: { css: ['~/assets/css/main.css'] } })"
        }
      ],
      "correctId": "1",
      "explanation": "Global styles are added using the 'css' array in nuxt.config.ts, which will include the styles in every page of the application."
    },
    {
      "title": "How do you create a composable in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file in /composables/ starting with 'use'"
        },
        {
          "id": "2",
          "text": "Create a file in /utils/ directory"
        },
        {
          "id": "3",
          "text": "Register it in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Create a plugin file"
        },
        {
          "id": "5",
          "text": "Export it from a component"
        }
      ],
      "correctId": "1",
      "explanation": "Composables in Nuxt 3 are created by placing files in the /composables/ directory, typically with names starting with 'use', and they're auto-imported."
    },
    {
      "title": "What is the purpose of the useNuxtApp() composable?",
      "options": [
        {
          "id": "1",
          "text": "To access the Nuxt application instance"
        },
        {
          "id": "2",
          "text": "To handle routing"
        },
        {
          "id": "3",
          "text": "To manage state"
        },
        {
          "id": "4",
          "text": "To fetch data"
        },
        {
          "id": "5",
          "text": "To configure the app"
        }
      ],
      "correctId": "1",
      "explanation": "useNuxtApp() provides access to the Nuxt application instance, allowing you to access plugins, hooks, and other app-level functionality."
    },
    {
      "title": "Which is the correct way to handle form data in a server API route?",
      "options": [
        {
          "id": "1",
          "text": "const body = await readBody(event)"
        },
        {
          "id": "2",
          "text": "const body = event.node.req.body"
        },
        {
          "id": "3",
          "text": "const body = getRequestBody(event)"
        },
        {
          "id": "4",
          "text": "const body = event.body"
        },
        {
          "id": "5",
          "text": "const body = parseBody(event)"
        }
      ],
      "correctId": "1",
      "explanation": "readBody(event) is the correct Nuxt 3 utility to read and parse the request body in server API routes."
    },
    {
      "title": "What is the difference between app.vue and default layout?",
      "options": [
        {
          "id": "1",
          "text": "app.vue wraps the entire app, layouts wrap pages"
        },
        {
          "id": "2",
          "text": "They serve the same purpose"
        },
        {
          "id": "3",
          "text": "app.vue is for configuration, layouts for presentation"
        },
        {
          "id": "4",
          "text": "app.vue is optional, layouts are required"
        },
        {
          "id": "5",
          "text": "app.vue is for server-side, layouts for client-side"
        }
      ],
      "correctId": "1",
      "explanation": "app.vue is the root component that wraps the entire application, while layouts wrap individual pages and are more specific."
    },
    {
      "title": "How do you implement authentication middleware in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file in /middleware/ directory"
        },
        {
          "id": "2",
          "text": "Use the auth plugin"
        },
        {
          "id": "3",
          "text": "Configure it in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Use the useAuth composable"
        },
        {
          "id": "5",
          "text": "Create a server API route"
        }
      ],
      "correctId": "1",
      "explanation": "Authentication middleware is implemented by creating files in the /middleware/ directory that run before route navigation."
    },
    {
      "title": "What is the correct syntax for conditional rendering in Nuxt 3 templates?",
      "options": [
        {
          "id": "1",
          "text": "<div v-if=\"condition\">Content</div>"
        },
        {
          "id": "2",
          "text": "<div *ngIf=\"condition\">Content</div>"
        },
        {
          "id": "3",
          "text": "<div if={condition}>Content</div>"
        },
        {
          "id": "4",
          "text": "{condition && <div>Content</div>}"
        },
        {
          "id": "5",
          "text": "<div show=\"condition\">Content</div>"
        }
      ],
      "correctId": "1",
      "explanation": "Nuxt 3 uses Vue 3 template syntax, so conditional rendering is done with v-if, v-else-if, and v-else directives."
    },
    {
      "title": "How do you define route middleware that runs on every route?",
      "options": [
        {
          "id": "1",
          "text": "Name the middleware file with .global suffix"
        },
        {
          "id": "2",
          "text": "Add global: true to the middleware function"
        },
        {
          "id": "3",
          "text": "Register it in nuxt.config.ts router.middleware"
        },
        {
          "id": "4",
          "text": "Use the useGlobalMiddleware composable"
        },
        {
          "id": "5",
          "text": "Place it in /middleware/global/ directory"
        }
      ],
      "correctId": "1",
      "explanation": "Global middleware in Nuxt 3 is created by adding the .global suffix to the middleware filename, making it run on every route."
    },
    {
      "title": "What is the purpose of the useRequestHeaders() composable?",
      "options": [
        {
          "id": "1",
          "text": "To access HTTP request headers"
        },
        {
          "id": "2",
          "text": "To set response headers"
        },
        {
          "id": "3",
          "text": "To configure CORS headers"
        },
        {
          "id": "4",
          "text": "To handle authentication headers"
        },
        {
          "id": "5",
          "text": "To validate header formats"
        }
      ],
      "correctId": "1",
      "explanation": "useRequestHeaders() allows you to access HTTP request headers in both server and client contexts during SSR."
    },
    {
      "title": "Can you use Pinia for state management in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "1",
      "explanation": "Pinia is fully supported in Nuxt 3 and is the recommended state management solution, offering better TypeScript support than Vuex."
    },
    {
      "title": "What is the correct way to handle query parameters in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const route = useRoute(); route.query.param"
        },
        {
          "id": "2",
          "text": "const query = useQuery(); query.param"
        },
        {
          "id": "3",
          "text": "const params = useParams(); params.param"
        },
        {
          "id": "4",
          "text": "this.$route.query.param"
        },
        {
          "id": "5",
          "text": "getQuery().param"
        }
      ],
      "correctId": "1",
      "explanation": "Query parameters are accessed through the useRoute() composable's query property, which is reactive and updates when the URL changes."
    },
    {
      "title": "How do you optimize images in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use the <NuxtImg> component"
        },
        {
          "id": "2",
          "text": "Install @nuxt/image module"
        },
        {
          "id": "3",
          "text": "Use regular <img> tags"
        },
        {
          "id": "4",
          "text": "Both options 1 and 2"
        },
        {
          "id": "5",
          "text": "Image optimization is not available"
        }
      ],
      "correctId": "4",
      "explanation": "Image optimization in Nuxt 3 is achieved by installing the @nuxt/image module and using the <NuxtImg> component, which provides automatic optimization features."
    },
    {
      "title": "What is the purpose of the useAsyncData composable?",
      "options": [
        {
          "id": "1",
          "text": "To fetch data with custom key and handler"
        },
        {
          "id": "2",
          "text": "To handle async components"
        },
        {
          "id": "3",
          "text": "To manage async operations"
        },
        {
          "id": "4",
          "text": "To cache async results"
        },
        {
          "id": "5",
          "text": "To handle promises"
        }
      ],
      "correctId": "1",
      "explanation": "useAsyncData allows you to fetch data with a custom key and handler function, providing more control over data fetching than useFetch."
    },
    {
      "title": "How do you create a dynamic import in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const Component = defineAsyncComponent(() => import('~/components/MyComponent.vue'))"
        },
        {
          "id": "2",
          "text": "const Component = lazy(() => import('~/components/MyComponent.vue'))"
        },
        {
          "id": "3",
          "text": "const Component = import('~/components/MyComponent.vue')"
        },
        {
          "id": "4",
          "text": "const Component = loadComponent('~/components/MyComponent.vue')"
        },
        {
          "id": "5",
          "text": "const Component = dynamicImport('~/components/MyComponent.vue')"
        }
      ],
      "correctId": "1",
      "explanation": "Dynamic imports in Nuxt 3 use Vue 3's defineAsyncComponent with the import() function to create lazily loaded components."
    },
    {
      "title": "What is the purpose of the <Teleport> component in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To render content in a different DOM location"
        },
        {
          "id": "2",
          "text": "To handle navigation between pages"
        },
        {
          "id": "3",
          "text": "To communicate between components"
        },
        {
          "id": "4",
          "text": "To manage async operations"
        },
        {
          "id": "5",
          "text": "To optimize component loading"
        }
      ],
      "correctId": "1",
      "explanation": "<Teleport> is a Vue 3 feature that allows you to render component content in a different part of the DOM tree, useful for modals and overlays."
    },
    {
      "title": "How do you configure SASS/SCSS in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Install sass and use <style lang=\"scss\">"
        },
        {
          "id": "2",
          "text": "Install @nuxtjs/sass module"
        },
        {
          "id": "3",
          "text": "Configure webpack for SASS"
        },
        {
          "id": "4",
          "text": "Add sass: true to nuxt.config.ts"
        },
        {
          "id": "5",
          "text": "SASS is not supported in Nuxt 3"
        }
      ],
      "correctId": "1",
      "explanation": "SASS/SCSS support in Nuxt 3 is achieved by installing the 'sass' package and using lang=\"scss\" in style blocks."
    },
    {
      "title": "What is the correct way to handle redirects in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "await navigateTo('/new-path')"
        },
        {
          "id": "2",
          "text": "return redirect('/new-path')"
        },
        {
          "id": "3",
          "text": "useRouter().push('/new-path')"
        },
        {
          "id": "4",
          "text": "throw createError({ statusCode: 301, statusMessage: '/new-path' })"
        },
        {
          "id": "5",
          "text": "All options are correct"
        }
      ],
      "correctId": "1",
      "explanation": "navigateTo() is the recommended way to handle redirects in Nuxt 3, supporting both client and server-side redirects."
    },
    {
      "title": "Does Nuxt 3 provide built-in PWA support?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "2",
      "explanation": "Nuxt 3 doesn't have built-in PWA support, but you can use the @vite-pwa/nuxt module or @nuxtjs/pwa for PWA functionality."
    },
    {
      "title": "What is the purpose of the refresh() method in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To refetch data manually"
        },
        {
          "id": "2",
          "text": "To clear cached data"
        },
        {
          "id": "3",
          "text": "To refresh the page"
        },
        {
          "id": "4",
          "text": "To update the fetch URL"
        },
        {
          "id": "5",
          "text": "To restart the application"
        }
      ],
      "correctId": "1",
      "explanation": "The refresh() method from useFetch allows you to manually trigger a refetch of the data, useful for updating content based on user actions."
    },
    {
      "title": "How do you handle loading states with useAsyncData?",
      "options": [
        {
          "id": "1",
          "text": "const { data, pending } = await useAsyncData('key', fetcher)"
        },
        {
          "id": "2",
          "text": "const { data, loading } = useAsyncData('key', fetcher)"
        },
        {
          "id": "3",
          "text": "const { data, pending } = useAsyncData('key', fetcher)"
        },
        {
          "id": "4",
          "text": "const { data, status } = useAsyncData('key', fetcher)"
        },
        {
          "id": "5",
          "text": "const { data, isLoading } = useAsyncData('key', fetcher)"
        }
      ],
      "correctId": "3",
      "explanation": "useAsyncData returns a 'pending' reactive property that indicates whether the async operation is still in progress."
    },
    {
      "title": "What is the correct way to add external scripts in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "useHead({ script: [{ src: 'https://example.com/script.js' }] })"
        },
        {
          "id": "2",
          "text": "Add to head.script in nuxt.config.ts"
        },
        {
          "id": "3",
          "text": "Use <script> tag in template"
        },
        {
          "id": "4",
          "text": "All options are correct"
        },
        {
          "id": "5",
          "text": "Only options 1 and 2 are correct"
        }
      ],
      "correctId": "5",
      "explanation": "External scripts can be added using useHead() composable or by configuring them in nuxt.config.ts head.script array for global scripts."
    },
    {
      "title": "What is the purpose of the clearError() function?",
      "options": [
        {
          "id": "1",
          "text": "To clear error state and resume normal operation"
        },
        {
          "id": "2",
          "text": "To hide error messages"
        },
        {
          "id": "3",
          "text": "To reset form validation errors"
        },
        {
          "id": "4",
          "text": "To clear console errors"
        },
        {
          "id": "5",
          "text": "To restart the application"
        }
      ],
      "correctId": "1",
      "explanation": "clearError() is used to programmatically clear the current error state and return the application to normal operation from an error page."
    },
    {
      "title": "How do you create a custom error page for specific HTTP status codes?",
      "options": [
        {
          "id": "1",
          "text": "Use the status code in error.vue template logic"
        },
        {
          "id": "2",
          "text": "Create separate files like 404.vue, 500.vue"
        },
        {
          "id": "3",
          "text": "Configure status-specific errors in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Use middleware to handle different status codes"
        },
        {
          "id": "5",
          "text": "Nuxt 3 doesn't support custom error pages"
        }
      ],
      "correctId": "1",
      "explanation": "Custom error pages for specific HTTP status codes are handled within the error.vue file by checking the error.statusCode and displaying different content accordingly."
    },
    {
      "title": "What is the correct way to define a layout with props in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Layouts cannot receive props in Nuxt 3"
        },
        {
          "id": "2",
          "text": "Use slots to pass data to layouts"
        },
        {
          "id": "3",
          "text": "Define props in the layout component normally"
        },
        {
          "id": "4",
          "text": "Use provide/inject pattern"
        },
        {
          "id": "5",
          "text": "Use global state management"
        }
      ],
      "correctId": "1",
      "explanation": "Layouts in Nuxt 3 cannot directly receive props from pages. Data sharing should be done through composables, provide/inject, or global state management."
    },
    {
      "title": "How do you configure auto-imports in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Auto-imports are enabled by default"
        },
        {
          "id": "2",
          "text": "Configure imports in nuxt.config.ts"
        },
        {
          "id": "3",
          "text": "Place files in designated directories"
        },
        {
          "id": "4",
          "text": "All of the above"
        },
        {
          "id": "5",
          "text": "Auto-imports are not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Auto-imports in Nuxt 3 are enabled by default, can be configured in nuxt.config.ts, and work automatically for files in specific directories like /composables/."
    },
    {
      "title": "What is the purpose of the <NuxtLayout> component?",
      "options": [
        {
          "id": "1",
          "text": "To dynamically change layouts"
        },
        {
          "id": "2",
          "text": "To wrap page content with layout"
        },
        {
          "id": "3",
          "text": "To handle layout-specific routing"
        },
        {
          "id": "4",
          "text": "To optimize layout loading"
        },
        {
          "id": "5",
          "text": "To configure layout props"
        }
      ],
      "correctId": "2",
      "explanation": "<NuxtLayout> is used in app.vue to wrap page content with the appropriate layout, providing the structure for page rendering."
    },
    {
      "title": "How do you handle form submissions in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use @submit.prevent and handle with methods"
        },
        {
          "id": "2",
          "text": "Submit to server API routes"
        },
        {
          "id": "3",
          "text": "Use useFetch for form data posting"
        },
        {
          "id": "4",
          "text": "All options are valid approaches"
        },
        {
          "id": "5",
          "text": "Forms are not supported in Nuxt 3"
        }
      ],
      "correctId": "4",
      "explanation": "Form submissions in Nuxt 3 can be handled using traditional form events, server API routes, or data fetching composables depending on the use case."
    },
    {
      "title": "What is the correct way to implement SEO meta tags dynamically?",
      "options": [
        {
          "id": "1",
          "text": "useHead({ title: computed(() => data.value?.title) })"
        },
        {
          "id": "2",
          "text": "useSeoMeta({ title: () => data.value?.title })"
        },
        {
          "id": "3",
          "text": "Both options are correct"
        },
        {
          "id": "4",
          "text": "setMeta({ title: data.value?.title })"
        },
        {
          "id": "5",
          "text": "Dynamic SEO is not supported"
        }
      ],
      "correctId": "3",
      "explanation": "Dynamic SEO meta tags can be implemented using useHead() with reactive values or useSeoMeta() which is specifically designed for SEO-related metadata."
    },
    {
      "title": "What is the purpose of the <Suspense> component in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "To handle async component loading with fallback content"
        },
        {
          "id": "2",
          "text": "To create loading animations"
        },
        {
          "id": "3",
          "text": "To manage component state"
        },
        {
          "id": "4",
          "text": "To handle error boundaries"
        },
        {
          "id": "5",
          "text": "To optimize component rendering"
        }
      ],
      "correctId": "1",
      "explanation": "<Suspense> is a Vue 3 feature that allows you to handle async components with fallback content while they're loading, improving user experience during async operations."
    },
    {
      "title": "How do you create a nested route in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a folder with the same name as the parent route file"
        },
        {
          "id": "2",
          "text": "Use the nested: true option in definePageMeta"
        },
        {
          "id": "3",
          "text": "Configure nested routes in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Use the <router-view> component"
        },
        {
          "id": "5",
          "text": "Nested routes are not supported in Nuxt 3"
        }
      ],
      "correctId": "1",
      "explanation": "Nested routes in Nuxt 3 are created by making a folder with the same name as the parent route file, and the folder contains the child route files."
    },
    {
      "title": "How do you implement internationalization (i18n) in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Install @nuxtjs/i18n module"
        },
        {
          "id": "2",
          "text": "Use Vue i18n directly"
        },
        {
          "id": "3",
          "text": "Create custom translation composables"
        },
        {
          "id": "4",
          "text": "All options are possible"
        },
        {
          "id": "5",
          "text": "i18n is not supported in Nuxt 3"
        }
      ],
      "correctId": "4",
      "explanation": "Internationalization can be implemented using @nuxtjs/i18n module (recommended), Vue i18n directly, or custom translation solutions."
    },
    {
      "title": "What is the correct way to handle environment-specific configuration?",
      "options": [
        {
          "id": "1",
          "text": "Use different nuxt.config.ts files for each environment"
        },
        {
          "id": "2",
          "text": "Use process.env variables in nuxt.config.ts"
        },
        {
          "id": "3",
          "text": "Create .env files and use runtimeConfig"
        },
        {
          "id": "4",
          "text": "Both options 2 and 3 are correct"
        },
        {
          "id": "5",
          "text": "Environment-specific config is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Environment-specific configuration can be handled using process.env variables in nuxt.config.ts or by creating .env files and accessing them through runtimeConfig."
    },
    {
      "title": "Which of the following is NOT a valid Nuxt 3 composable?",
      "options": [
        {
          "id": "1",
          "text": "useRoute()"
        },
        {
          "id": "2",
          "text": "useRouter()"
        },
        {
          "id": "3",
          "text": "useStore()"
        },
        {
          "id": "4",
          "text": "useCookie()"
        },
        {
          "id": "5",
          "text": "useRuntimeConfig()"
        }
      ],
      "correctId": "3",
      "explanation": "useStore() is not a built-in Nuxt 3 composable. Nuxt 3 doesn't include Vuex by default, and state management is typically handled with Pinia or custom composables."
    },
    {
      "title": "How do you implement route validation in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "definePageMeta({ validate: (route) => { return /^\\d+$/.test(route.params.id) } })"
        },
        {
          "id": "2",
          "text": "Use middleware for route validation"
        },
        {
          "id": "3",
          "text": "Configure validation in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Use the validate() lifecycle hook"
        },
        {
          "id": "5",
          "text": "Route validation is not supported"
        }
      ],
      "correctId": "1",
      "explanation": "Route validation in Nuxt 3 is implemented using definePageMeta with a validate function that receives the route object and returns a boolean."
    },
    {
      "title": "What is the purpose of the useLazyAsyncData composable?",
      "options": [
        {
          "id": "1",
          "text": "To fetch data without blocking navigation"
        },
        {
          "id": "2",
          "text": "To cache data for better performance"
        },
        {
          "id": "3",
          "text": "To handle large datasets efficiently"
        },
        {
          "id": "4",
          "text": "To delay data fetching until needed"
        },
        {
          "id": "5",
          "text": "To fetch data in the background"
        }
      ],
      "correctId": "1",
      "explanation": "useLazyAsyncData allows data fetching without blocking client-side navigation, similar to useLazyFetch but with more control over the async operation."
    },
    {
      "title": "Can Nuxt 3 generate static sites (SSG)?",
      "options": [
        {
          "id": "1",
          "text": "true"
        },
        {
          "id": "2",
          "text": "false"
        }
      ],
      "correctId": "1",
      "explanation": "Nuxt 3 fully supports Static Site Generation (SSG) through the 'nuxt generate' command, creating pre-rendered HTML files for all routes."
    },
    {
      "title": "What is the correct way to add a favicon in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Place favicon.ico in the public/ directory"
        },
        {
          "id": "2",
          "text": "Configure it in nuxt.config.ts head.link"
        },
        {
          "id": "3",
          "text": "Use useHead() to set favicon link"
        },
        {
          "id": "4",
          "text": "All options are correct"
        },
        {
          "id": "5",
          "text": "Only options 1 and 2 are correct"
        }
      ],
      "correctId": "5",
      "explanation": "Favicons can be added by placing them in the public/ directory (automatically served) or by configuring them in nuxt.config.ts head.link array for global setup."
    },
    {
      "title": "How do you implement custom error handling for specific routes?",
      "options": [
        {
          "id": "1",
          "text": "Use try-catch in the route component"
        },
        {
          "id": "2",
          "text": "throw createError() to trigger error page"
        },
        {
          "id": "3",
          "text": "Use route-specific middleware"
        },
        {
          "id": "4",
          "text": "All options are valid approaches"
        },
        {
          "id": "5",
          "text": "Custom error handling is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Custom error handling can be implemented using try-catch blocks, throwing createError() to trigger the error page, or using route-specific middleware."
    },
    {
      "title": "What is the purpose of the useRequestURL() composable?",
      "options": [
        {
          "id": "1",
          "text": "To get the current request URL"
        },
        {
          "id": "2",
          "text": "To modify the current URL"
        },
        {
          "id": "3",
          "text": "To validate URL parameters"
        },
        {
          "id": "4",
          "text": "To handle URL redirects"
        },
        {
          "id": "5",
          "text": "To parse URL components"
        }
      ],
      "correctId": "1",
      "explanation": "useRequestURL() provides access to the current request URL object, useful for accessing the full URL including origin, pathname, and search parameters."
    },
    {
      "title": "How do you implement code splitting for specific components?",
      "options": [
        {
          "id": "1",
          "text": "Use defineAsyncComponent(() => import('./Component.vue'))"
        },
        {
          "id": "2",
          "text": "Add 'Lazy' prefix to component name"
        },
        {
          "id": "3",
          "text": "Configure code splitting in nuxt.config.ts"
        },
        {
          "id": "4",
          "text": "Both options 1 and 2 are correct"
        },
        {
          "id": "5",
          "text": "Code splitting is automatic in Nuxt 3"
        }
      ],
      "correctId": "4",
      "explanation": "Code splitting for components can be achieved using defineAsyncComponent with dynamic imports or by prefixing component names with 'Lazy' in Nuxt 3."
    },
    {
      "title": "What is the correct syntax for defining a server middleware in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create a file in /server/middleware/ directory"
        },
        {
          "id": "2",
          "text": "Use defineEventHandler in /server/api/"
        },
        {
          "id": "3",
          "text": "Configure middleware in nitro.config.ts"
        },
        {
          "id": "4",
          "text": "Add middleware to nuxt.config.ts serverHandlers"
        },
        {
          "id": "5",
          "text": "Server middleware is not supported"
        }
      ],
      "correctId": "1",
      "explanation": "Server middleware in Nuxt 3 is created by placing files in the /server/middleware/ directory, which will run on every server request."
    },
    {
      "title": "How do you implement route transitions in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "definePageMeta({ transition: 'slide' })"
        },
        {
          "id": "2",
          "text": "Configure transitions in nuxt.config.ts"
        },
        {
          "id": "3",
          "text": "Use CSS classes for page transitions"
        },
        {
          "id": "4",
          "text": "All options can be used"
        },
        {
          "id": "5",
          "text": "Route transitions are not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Route transitions can be implemented using definePageMeta, global configuration in nuxt.config.ts, or custom CSS classes for transition effects."
    },
    {
      "title": "What is the purpose of the key property in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To provide a unique identifier for caching"
        },
        {
          "id": "2",
          "text": "To set authentication keys"
        },
        {
          "id": "3",
          "text": "To define sort keys for data"
        },
        {
          "id": "4",
          "text": "To specify encryption keys"
        },
        {
          "id": "5",
          "text": "To handle API keys"
        }
      ],
      "correctId": "1",
      "explanation": "The key property in useFetch provides a unique identifier for caching the request, preventing duplicate requests and managing cache invalidation."
    },
    {
      "title": "How do you implement custom directory imports in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Configure imports.dirs in nuxt.config.ts"
        },
        {
          "id": "2",
          "text": "Use the #imports alias"
        },
        {
          "id": "3",
          "text": "Create an index.ts file in the directory"
        },
        {
          "id": "4",
          "text": "Add directory to auto-scan paths"
        },
        {
          "id": "5",
          "text": "Custom directory imports are not supported"
        }
      ],
      "correctId": "1",
      "explanation": "Custom directory imports are configured using the imports.dirs array in nuxt.config.ts, allowing auto-imports from specified directories."
    },
    {
      "title": "What is the difference between useFetch and $fetch in error handling?",
      "options": [
        {
          "id": "1",
          "text": "useFetch provides error reactive refs, $fetch requires try-catch"
        },
        {
          "id": "2",
          "text": "$fetch has better error handling"
        },
        {
          "id": "3",
          "text": "Both handle errors the same way"
        },
        {
          "id": "4",
          "text": "useFetch cannot handle errors"
        },
        {
          "id": "5",
          "text": "$fetch cannot handle errors"
        }
      ],
      "correctId": "1",
      "explanation": "useFetch returns reactive error refs for declarative error handling, while $fetch requires manual try-catch blocks for error handling."
    },
    {
      "title": "How do you implement content security policy (CSP) in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Configure security headers in nuxt.config.ts"
        },
        {
          "id": "2",
          "text": "Use @nuxtjs/security module"
        },
        {
          "id": "3",
          "text": "Set headers in server middleware"
        },
        {
          "id": "4",
          "text": "All options are valid approaches"
        },
        {
          "id": "5",
          "text": "CSP is not supported in Nuxt 3"
        }
      ],
      "correctId": "4",
      "explanation": "Content Security Policy can be implemented through security headers in nuxt.config.ts, using security modules, or setting headers in server middleware."
    },
    {
      "title": "What is the purpose of the transform option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To transform response data before returning"
        },
        {
          "id": "2",
          "text": "To transform request parameters"
        },
        {
          "id": "3",
          "text": "To handle data encryption"
        },
        {
          "id": "4",
          "text": "To convert data types"
        },
        {
          "id": "5",
          "text": "To compress response data"
        }
      ],
      "correctId": "1",
      "explanation": "The transform option in useFetch allows you to process and transform the response data before it's returned, useful for data normalization or extraction."
    },
    {
      "title": "How do you implement custom page loading indicators in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Configure loading in nuxt.config.ts"
        },
        {
          "id": "2",
          "text": "Use the <NuxtLoadingIndicator> component"
        },
        {
          "id": "3",
          "text": "Create custom loading middleware"
        },
        {
          "id": "4",
          "text": "Use pending states from data fetching composables"
        },
        {
          "id": "5",
          "text": "All options are valid approaches"
        }
      ],
      "correctId": "5",
      "explanation": "Custom loading indicators can be implemented using configuration, the built-in NuxtLoadingIndicator component, custom middleware, or pending states from composables."
    },
    {
      "title": "What is the purpose of the watch option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To automatically refetch when dependencies change"
        },
        {
          "id": "2",
          "text": "To monitor network requests"
        },
        {
          "id": "3",
          "text": "To watch for file changes"
        },
        {
          "id": "4",
          "text": "To observe component lifecycle"
        },
        {
          "id": "5",
          "text": "To track user interactions"
        }
      ],
      "correctId": "1",
      "explanation": "The watch option in useFetch allows you to specify reactive dependencies that will trigger an automatic refetch when their values change."
    },
    {
      "title": "How do you implement custom 500 error handling in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "throw createError({ statusCode: 500, statusMessage: 'Server Error' })"
        },
        {
          "id": "2",
          "text": "Use try-catch in server routes"
        },
        {
          "id": "3",
          "text": "Handle in error.vue with error.statusCode check"
        },
        {
          "id": "4",
          "text": "All options are correct"
        },
        {
          "id": "5",
          "text": "500 errors cannot be customized"
        }
      ],
      "correctId": "4",
      "explanation": "Custom 500 error handling can be implemented using createError(), try-catch blocks in server routes, and custom handling in error.vue based on statusCode."
    },
    {
      "title": "What is the correct way to implement role-based authentication middleware?",
      "options": [
        {
          "id": "1",
          "text": "export default defineNuxtRouteMiddleware((to) => { if (!hasRole(to.meta.requiredRole)) { throw createError({ statusCode: 403 }) } })"
        },
        {
          "id": "2",
          "text": "Use server-side validation only"
        },
        {
          "id": "3",
          "text": "Implement in component mounted hooks"
        },
        {
          "id": "4",
          "text": "Configure in nuxt.config.ts security settings"
        },
        {
          "id": "5",
          "text": "Role-based auth is not supported"
        }
      ],
      "correctId": "1",
      "explanation": "Role-based authentication middleware is implemented using defineNuxtRouteMiddleware with role checking logic that can throw appropriate errors for unauthorized access."
    },
    {
      "title": "How do you implement lazy loading for images in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "<NuxtImg loading=\"lazy\" src=\"/image.jpg\" />"
        },
        {
          "id": "2",
          "text": "<img loading=\"lazy\" src=\"/image.jpg\" />"
        },
        {
          "id": "3",
          "text": "Use Intersection Observer API"
        },
        {
          "id": "4",
          "text": "All options are valid"
        },
        {
          "id": "5",
          "text": "Lazy loading is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Lazy loading for images can be implemented using NuxtImg component, native HTML loading attribute, or custom Intersection Observer implementation."
    },
    {
      "title": "What is the purpose of the server option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To control whether the request runs on server during SSR"
        },
        {
          "id": "2",
          "text": "To specify the server endpoint"
        },
        {
          "id": "3",
          "text": "To configure server timeout"
        },
        {
          "id": "4",
          "text": "To enable server-side caching"
        },
        {
          "id": "5",
          "text": "To set server authentication"
        }
      ],
      "correctId": "1",
      "explanation": "The server option in useFetch controls whether the request should be executed on the server during server-side rendering or only on the client."
    },
    {
      "title": "How do you implement breadcrumbs in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use route.matched to build breadcrumb trail"
        },
        {
          "id": "2",
          "text": "Define breadcrumbs in definePageMeta"
        },
        {
          "id": "3",
          "text": "Create a composable to generate breadcrumbs"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "Breadcrumbs require external libraries"
        }
      ],
      "correctId": "4",
      "explanation": "Breadcrumbs can be implemented using route.matched array, defining them in page metadata, or creating custom composables to generate breadcrumb trails."
    },
    {
      "title": "What is the difference between app.config.ts and nuxt.config.ts?",
      "options": [
        {
          "id": "1",
          "text": "app.config.ts is for runtime config, nuxt.config.ts is for build-time config"
        },
        {
          "id": "2",
          "text": "app.config.ts is for client-side, nuxt.config.ts is for server-side"
        },
        {
          "id": "3",
          "text": "app.config.ts is for production, nuxt.config.ts is for development"
        },
        {
          "id": "4",
          "text": "They serve the same purpose"
        },
        {
          "id": "5",
          "text": "app.config.ts is deprecated"
        }
      ],
      "correctId": "1",
      "explanation": "app.config.ts contains runtime configuration that can be updated without rebuilding, while nuxt.config.ts contains build-time configuration that requires a rebuild to change."
    },
    {
      "title": "How do you implement dark mode toggle in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use @nuxtjs/color-mode module"
        },
        {
          "id": "2",
          "text": "Implement custom theme switching with useState"
        },
        {
          "id": "3",
          "text": "Use CSS variables and localStorage"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "Dark mode is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Dark mode can be implemented using the @nuxtjs/color-mode module, custom state management with useState, or CSS variables with localStorage persistence."
    },
    {
      "title": "What is the correct way to handle file uploads in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use FormData with $fetch in client-side handler"
        },
        {
          "id": "2",
          "text": "Process multipart/form-data in server API routes"
        },
        {
          "id": "3",
          "text": "Use libraries like multer for file processing"
        },
        {
          "id": "4",
          "text": "All options are valid approaches"
        },
        {
          "id": "5",
          "text": "File uploads are not supported"
        }
      ],
      "correctId": "4",
      "explanation": "File uploads can be handled using FormData on the client, processing multipart data in server routes, or using specialized libraries for file handling."
    },
    {
      "title": "How do you implement infinite scrolling in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use Intersection Observer with useFetch refresh()"
        },
        {
          "id": "2",
          "text": "Combine scroll events with data fetching composables"
        },
        {
          "id": "3",
          "text": "Use pagination with useAsyncData"
        },
        {
          "id": "4",
          "text": "All approaches can work"
        },
        {
          "id": "5",
          "text": "Infinite scrolling requires external libraries"
        }
      ],
      "correctId": "4",
      "explanation": "Infinite scrolling can be implemented using Intersection Observer, scroll events, or pagination techniques combined with Nuxt's data fetching composables."
    },
    {
      "title": "What is the purpose of the immediate option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To control when the request is executed"
        },
        {
          "id": "2",
          "text": "To make requests synchronous"
        },
        {
          "id": "3",
          "text": "To prioritize request execution"
        },
        {
          "id": "4",
          "text": "To handle immediate responses"
        },
        {
          "id": "5",
          "text": "To set request timeouts"
        }
      ],
      "correctId": "1",
      "explanation": "The immediate option in useFetch controls whether the request should be executed immediately when the composable is called or wait for manual triggering."
    },
    {
      "title": "How do you implement search functionality with debouncing in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "const searchQuery = ref(''); const debouncedQuery = debounce(searchQuery, 300); watch(debouncedQuery, fetchResults)"
        },
        {
          "id": "2",
          "text": "Use useLazyFetch with watch on search input"
        },
        {
          "id": "3",
          "text": "Implement custom debounce composable"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "Debouncing is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Search with debouncing can be implemented using debounce utilities, useLazyFetch with watched inputs, or custom composables that handle delayed execution."
    },
    {
      "title": "What is the correct way to implement WebSocket connections in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use native WebSocket API in client-side code"
        },
        {
          "id": "2",
          "text": "Implement WebSocket handling in plugins"
        },
        {
          "id": "3",
          "text": "Use libraries like socket.io with Nuxt plugins"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "WebSockets are not supported"
        }
      ],
      "correctId": "4",
      "explanation": "WebSocket connections can be implemented using native WebSocket API, through plugins for lifecycle management, or with libraries like socket.io integrated via Nuxt plugins."
    },
    {
      "title": "How do you implement progressive web app (PWA) caching strategies?",
      "options": [
        {
          "id": "1",
          "text": "Configure service worker caching rules"
        },
        {
          "id": "2",
          "text": "Use @vite-pwa/nuxt module with caching options"
        },
        {
          "id": "3",
          "text": "Implement custom cache-first or network-first strategies"
        },
        {
          "id": "4",
          "text": "All options are valid"
        },
        {
          "id": "5",
          "text": "PWA caching is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "PWA caching strategies can be implemented through service worker configuration, PWA modules with built-in options, or custom cache strategies based on application needs."
    },
    {
      "title": "What is the purpose of the dedupe option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To prevent duplicate requests with the same key"
        },
        {
          "id": "2",
          "text": "To remove duplicate data from responses"
        },
        {
          "id": "3",
          "text": "To eliminate redundant API calls"
        },
        {
          "id": "4",
          "text": "To compress request payloads"
        },
        {
          "id": "5",
          "text": "To handle duplicate submissions"
        }
      ],
      "correctId": "1",
      "explanation": "The dedupe option in useFetch prevents multiple requests with the same key from being executed simultaneously, reducing unnecessary network calls."
    },
    {
      "title": "How do you implement component-level error boundaries in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use onErrorCaptured lifecycle hook"
        },
        {
          "id": "2",
          "text": "Wrap components with <Suspense> and error handling"
        },
        {
          "id": "3",
          "text": "Create custom error boundary components"
        },
        {
          "id": "4",
          "text": "All approaches can be used"
        },
        {
          "id": "5",
          "text": "Error boundaries are not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Component-level error boundaries can be implemented using onErrorCaptured hooks, Suspense components with error handling, or custom wrapper components."
    },
    {
      "title": "What is the correct way to implement real-time updates in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Use Server-Sent Events (SSE)"
        },
        {
          "id": "2",
          "text": "Implement WebSocket connections"
        },
        {
          "id": "3",
          "text": "Use polling with useFetch refresh"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "Real-time updates require external services"
        }
      ],
      "correctId": "4",
      "explanation": "Real-time updates can be implemented using Server-Sent Events, WebSockets, or polling strategies with Nuxt's data fetching composables."
    },
    {
      "title": "How do you implement custom validators for form fields in Nuxt 3?",
      "options": [
        {
          "id": "1",
          "text": "Create composables with validation logic"
        },
        {
          "id": "2",
          "text": "Use libraries like Vuelidate or VeeValidate"
        },
        {
          "id": "3",
          "text": "Implement custom validation with reactive refs"
        },
        {
          "id": "4",
          "text": "All approaches are valid"
        },
        {
          "id": "5",
          "text": "Form validation is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "Form validation can be implemented using custom composables, validation libraries like Vuelidate/VeeValidate, or custom reactive validation logic."
    },
    {
      "title": "What is the purpose of the getCachedData option in useFetch?",
      "options": [
        {
          "id": "1",
          "text": "To provide custom cache retrieval logic"
        },
        {
          "id": "2",
          "text": "To get cached data size information"
        },
        {
          "id": "3",
          "text": "To validate cached data integrity"
        },
        {
          "id": "4",
          "text": "To clear cached data"
        },
        {
          "id": "5",
          "text": "To compress cached data"
        }
      ],
      "correctId": "1",
      "explanation": "The getCachedData option in useFetch allows you to provide custom logic for retrieving cached data, giving you control over cache behavior."
    },
    {
      "title": "How do you implement API rate limiting in Nuxt 3 server routes?",
      "options": [
        {
          "id": "1",
          "text": "Use server middleware to track request counts"
        },
        {
          "id": "2",
          "text": "Implement rate limiting with Redis or in-memory storage"
        },
        {
          "id": "3",
          "text": "Use libraries like express-rate-limit adapted for h3"
        },
        {
          "id": "4",
          "text": "All approaches can work"
        },
        {
          "id": "5",
          "text": "Rate limiting is not supported"
        }
      ],
      "correctId": "4",
      "explanation": "API rate limiting can be implemented using server middleware, storage solutions like Redis, or adapting existing rate limiting libraries for h3 server framework."
    }
  ]
}
